# ACID
- Atomic(원자성) : 전부 반영되거나 전부 반영되지 않아야한다는 성질
- Consistency(일관성) : 트랜잭션 실행 이전과 이후가 항상 동일한 상태로 안정되야 한다는 성질(테이블의 제약조건 등이 바뀌면 안됨)
- Isolatioon(고립성) : 각 트랜잭션이 서로 고립되게 실행되고 영향을 주면 안된다는 성질
- Duratbility(지속성) : 한번 수행된 트랜잭션은 영속적로 반영되어야 한다는 성질

# 정규화, 비정규화
### 정규화

데이터 베이스의 일관성, 유연성을 확보하기 위한 목적으로 데이터를 분해하는 과정을 말함.

- 불필요하거나 중복되는 데이터들을 제거함.
- 이상현상을 방지함.

### 정규화 절차

- 제 1정규화 : 속성의 원자성을 확보하고 원자값이 아닌 도메인을 분해함.
- 제 2정규화 : 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거함.(기본키 하나로 데이터가 구분되는 경우 테이블을 나눠야함)
- 제 3정규화 : 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는것을 의미함. (예를들어, A → B → C로 종속적일때, A→B, B→C로 테블을 분해해야함)

### 비정규화

정규화된 데이터 베이스를 시스템의 성능 향상과 운영의 단수화를 위해 데이터를 중복 통합, 분리 등을 수행하는 과정을 말함.

### 비정규화 장단점

장점: 성능 향상과 관리의 효율성이 증가 (테이블 Join등이 줄어들어 조회성능이 향상 됨)

단점: 데이터 일관성, 정합성 저하시킴 & 저장/유지를 위한 별도 비용이 발생 할 수 있음(정규화를 반하기 때문)

### 💡비정규화 대상 예시

*예를 들어, Orders와 Products라는 테이블로 이루어진 정규화된 데이터베이스를 생각해 보자. Orders 테이블에는 productlD를 둘 수는 있어도, productName이라는 필드를 두지는 않을 것이다. 따라서 주문 정보와 상품 이름을 함께 나열하고 싶은 경우에는 두 테이블을 조인해야 한다.*

*어떤 면에서는 멋진 방법이다. 상품이 자신의 이름을 바꿀 경우, 한 곳의 데이터만 갱신하면 된다.*

*하지만 이 방법의 단점은 테이블이 아주 클 경우 조인을 하느라 불필요할 정도로 많은 시간을 낭비하게 된다는 것이다.*

### 비정규화 대상

1. 자주 사용되는 테이블에 조회 쿼리가 많은 경우
2. 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 이슈가 있을 경우
3. 테이블에 지나치게 많은 조인을 사용하게 되어 데이터 조회하는 것이 어려운 경우



# join 작동 방식
# inner join, outer join
- InnerJoin : 두 테이블을 조인할 때, 두 테이블에 모두 지정한 열의 데이터가 있어야함.
- OuterJoin :  두 테이블을 조인할 때, 1개의 테이블에만 데이터가 있어도 결과가 나옴(반대쪽 테이블의 칼럼을 null로 채움).
    - LEFT OUTER JOIN: 왼쪽 테이블의 모든 값이 출력되는 조인
    - RIGHT OUTER JOIN: 오른쪽 테이블의 모든 값이 출력되는 조인
    - FULL OUTER JOIN: 왼쪽 또는 오른쪽 테이블의 모든 값이 출력되는 조인
    
# ORM이란
ObjectRelationalMapping의 약자이다. 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다.

💡객체와 테이블의 차이

각 테이블은 양방향 참조를 할 수 있다. 예를 들어, 주문 테이블에 상품 정보가 저장되어있으면, 주문 → 상품 조회가 가능하고 상품 → 주문 조회가 가능하다. 하지만 객체는 일반적으로 단방향 참조를 한다. 주문 → 상품의 참조 관계라면 상품이 주문에 접근 할 수 없다. 이러한 객체와 DB 테이블 간의 간극을 맺어주는것이 ORM이다.


# SQL, NoSQL


# drop, truncate, delete의 차이점을 설명해주세요
- drop 명령어 : DB 테이블 정의 및 해당 테이블에 대한 모든 데이터, 인덱스, 권한을 제거함. 모두 제거하기에 RollBack이 불가능하다.
- delete 명령어 : 테이블 내부의 행을 모두 삭제하며, WHERER 절을 상요하여 개별적으로 행을 삭제할 수 있음.
- truncate 명렁어 : DB 테이블 내부의 모든 행을 삭제함. 권한, 인덱스 등을 제거하지 않고 행만을 삭제함.


# query 수행 순서
- **FROM** : 각 테이블 확인
- **ON** : 조인 조건 확인
- **JOIN** : 테이블 조인 (병합)
- **WHERE** : 데이터 추출 조건 확인
- **GROUP BY** : 특정 칼럼으로 데이터 그룹화
- **HAVING** : 그룹화 이후 데이터 추출 조건 확인
- **SELECT** : 데이터 추출
- **DISTINCT** : 중복 제거
- **ORDER BY** : 데이터 정렬

💡 LIMIT 쿼리

LIMIT 쿼리는 ORDER BY 이후에 실행됨.

💡 WHERE과 ON의 차이점 

WHERE과 ON 모두 Join시에 데이터를 비교하는 연산자이다. 하지만 ON은 Join전에 조건을 필터링 하고 WHERE은 Join 후에 조건을 필터링 한다.

InnerJoin을 하는 경우, 두 조건문은 차이점을 가지지 않는다. 하지만 OuterJoin을 수행하게 되면 두가지 조건문은 큰차이를 가진다. 

OuterJoin은 조건문과 일치하는 데이터가 없으면 null로 값을 채워 레코드를 생성한다. 그래서 ON 조건과 일치하는 데이터가 없는 경우 결과 테이블에는 null로 값이 채워지게 된다. 

하지만 WHERE은 JOIN 수행 후의 레코드에 대해 비교조건을 수행한다. 그래서 비교조건과 일치하는 레코드가 없으면(null인 경우) 해당 레코드를 결과 테이블에서 제거한다.
# connection pool
어플리케이션에서 DB에 데이터를 저장하려고 하면 DB Connection을 생성해야한다. 아래의 과정이 수행된다.

![image](https://user-images.githubusercontent.com/71062817/236664809-aae17cea-5b11-481e-8cfb-deecce771578.png)


위 과정의 3~6번도 번거롭지만 2번 과정에서는 TCP/IP 통신이 발생한다. 그래서 네트워크 통신 비용이 발생하고 성능저하의 원인이 될 수 있다. 클라이언트가 요청에 대한 응답을 받을 때, 어플리케이션과 DB 통신시간이 포함되기 때문이다.

그래서 DB ConnectionPool 이라는 바구니에 Connection 정보를 미리 담아두고 이를 통해 어플리케이션과 DB가 통신을 하도록 하는 것을 ConnectionPool이라고 한다.

![image](https://user-images.githubusercontent.com/71062817/236664815-5dc341ce-9a47-4b14-9228-d6c8785d37f6.png)


ConnectionPool은 설정에 따라 어플리케이션 초기화와 함께 DBConnection을 생성하고 담아두거나 일정 시간마다 DBConnection을 관리해준다. 그리고 TCP/IP의 통신 연결및 종료 과정을 생략하므로 성능상의 이점이 있다.

### ConnectionPool 크기

그렇다면 ConnectionPool을 크게 가져가면 성능이 무조건 좋아질까? 아니다. ConnectionPool은 DB의 하드웨어 성능을 고려하여 설정하는 것이 좋다. 왜냐하면 ConnectionPool에 담긴 커넥션이 100개 이고 100개의 요청에 모두 DBConnection을 할당 해주어도 DB 서버의 CPU core가 한개라면 요청 처리를 위해 99개의 커넥션은 대기해야하기 때문이다. 이때, 컨텍스트 스위칭 비용이 커지고 병목이 발생한다.

Spring은 기본 제공하는 DB ConnectionPool에서 *아래와 같은 공식을 제공한다.*

```java
DB 서버의 CPU core * 2 + HDD SPINDLE 개수
```

위와 같은 설정이 최적의 성능을 제공 할 수 있다고 벤치마크와 함께 공싱
# 트랜젹션 (여기까지 ~5월 7일))


# 낙관적 락, 비관적 락, 분산 락을 설명해주세요
# mvcc
# 인덱스
# Cap 이론
# 레디스
# uuid vs auto increament
# utf-8 vs mb4
# Datetime vs timestamp
